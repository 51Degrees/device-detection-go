package fodcache

/* *********************************************************************
 * This Original Work is copyright of 51 Degrees Mobile Experts Limited.
 * Copyright 2019 51 Degrees Mobile Experts Limited, 5 Charlotte Close,
 * Caversham, Reading, Berkshire, United Kingdom RG4 7BY.
 *
 * This Original Work is licensed under the European Union Public Licence (EUPL)
 * v.1.2 and is subject to its terms as set out below.
 *
 * If a copy of the EUPL was not distributed with this file, You can obtain
 * one at https://opensource.org/licenses/EUPL-1.2.
 *
 * The 'Compatible Licences' set out in the Appendix to the EUPL (as may be
 * amended by the European Commission) shall be deemed incompatible for
 * the purposes of the Work and the provisions of the compatibility
 * clause in Article 5 of the EUPL shall not apply.
 *
 * If using the Work as, or as part of, a network application, by
 * including the attribution notice(s) required under Article 5 of the EUPL
 * in the end user terms of the application under an appropriate heading,
 * such notice(s) shall fulfill the requirements of that article.
 * ********************************************************************* */

/**
 * Extension of general cache contract to provide for getting a value with a particular
 * value loaded. Primarily used to allow the value loader to be an already instantiated object
 * <p>
 * Used only in UA Matching.
 */
type LruLoadingCache struct {
	LruCacheBase
	ILoadingCache
	loader IValueLoader
}

/**
 * Instantiate a new LoadingCache
 * @class	LruLoadingCache
 * @param 	cb	Builder Options for Cache
 * @return 	*LruLoadingCache, error	Pointer to newly instantiated cache, any errors generated by the process
 */
func NewLruLoadingCache(cb CacheBuilder) (*LruLoadingCache, error) {
	llc := LruLoadingCache{}
	llc.setCacheLoader(cb.Loader)
	err := llc.Build(&cb)
	if err != nil {
		return nil,err
	}
	return &llc, nil
}

/**
 * Loader used to fetch items not in the cache.
 * @class LruLoadingCache
 * @param loader - pointer to a user-written loading cache implementing IValueLoader interface
 */
func (llc *LruLoadingCache) setCacheLoader(loader IValueLoader) {
	llc.loader = loader
}

/**
 * Retrieves the value for key requested. If the key does not exist
 * in the cache then the Fetch method of the cache's loader is used to
 * retrieve the value.
 *
 * @class LruLoadingCache
 * @param key or the item required.
 * @return An instance of the value associated with the key.
 * @throws IllegalStateException (if there was a problem accessing data file), error
 */
func (llc  LruLoadingCache) Get(key interface{}) (interface{}, error) {
	val, err := llc.GetWithLoadingCache(key, llc.loader)
	if err != nil {
		// looks for IO Exception on value loader
		// throws illegalStateException... er, kinda.
		return nil,err
	}
	return val,nil
}

/**
 * Retrieves the value for key requested. If the key does not exist
 * in the cache then the Fetch method is used to retrieve the value
 * from another loader.
 *
 * @param key    or the item required
 * @param loader to fetch the items from
 * @return An instance of the value associated with the key
 * @throws IOExceptionError, error
 */
func (llc *LruLoadingCache) GetWithLoadingCache(key interface{}, loader IValueLoader) (interface{}, error) {
	result, err := llc.LruCacheBase.Get(key);
	if err != nil {
		return nil, err
	}
	if result == nil && loader != nil {
		result, err = loader.Load(key)
		if err != nil {
			return nil, IOExceptionError
		}
		_, err := llc.Add(key, result)
		if err != nil {
			return nil,err
		}
		return result,nil
	}
	return result,nil
}