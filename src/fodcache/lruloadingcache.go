package fodcache

/*******************************************************************************
 * This Source Code Form is copyright of 51Degrees Mobile Experts Limited.
 * Copyright 2017 51Degrees Mobile Experts Limited, 5 Charlotte Close,
 * Caversham, Reading, Berkshire, United Kingdom RG4 7BY
 *
 * This Source Code Form is the subject of the following patents and patent
 * applications, owned by 51Degrees Mobile Experts Limited of 5 Charlotte
 * Close, Caversham, Reading, Berkshire, United Kingdom RG4 7BY:
 * European Patent No. 2871816;
 * European Patent Application No. 17184134.9;
 * United States Patent Nos. 9,332,086 and 9,350,823; and
 * United States Patent Application No. 15/686,066.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0.
 *
 * If a copy of the MPL was not distributed with this file, You can obtain
 * one at http://mozilla.org/MPL/2.0/.
 *
 * This Source Code Form is "Incompatible With Secondary Licenses", as
 * defined by the Mozilla Public License, v. 2.0.
 ******************************************************************************/

/**
 * Extension of general cache contract to provide for getting a value with a particular
 * value loaded. Primarily used to allow the value loader to be an already instantiated object
 * <p>
 * Used only in UA Matching.
 */
type LruLoadingCache struct {
	LruCacheBase
	ILoadingCache
	loader IValueLoader
}

/**
 * Instantiate a new LoadingCache
 * @class	LruLoadingCache
 * @param 	cb	Builder Options for Cache
 * @return 	*LruLoadingCache, error	Pointer to newly instantiated cache, any errors generated by the process
 */
func NewLruLoadingCache(cb CacheBuilder) (*LruLoadingCache, error) {
	llc := LruLoadingCache{}
	llc.setCacheLoader(cb.Loader)
	err := llc.Build(&cb)
	if err != nil {
		return nil,err
	}
	return &llc, nil
}

/**
 * Loader used to fetch items not in the cache.
 * @class LruLoadingCache
 * @param loader - pointer to a user-written loading cache implementing IValueLoader interface
 */
func (llc *LruLoadingCache) setCacheLoader(loader IValueLoader) {
	llc.loader = loader
}

/**
 * Retrieves the value for key requested. If the key does not exist
 * in the cache then the Fetch method of the cache's loader is used to
 * retrieve the value.
 *
 * @class LruLoadingCache
 * @param key or the item required.
 * @return An instance of the value associated with the key.
 * @throws IllegalStateException (if there was a problem accessing data file), error
 */
func (llc  LruLoadingCache) Get(key interface{}) (interface{}, error) {
	val, err := llc.GetWithLoadingCache(key, llc.loader)
	if err != nil {
		// looks for IO Exception on value loader
		// throws illegalStateException... er, kinda.
		return nil,err
	}
	return val,nil
}

/**
 * Retrieves the value for key requested. If the key does not exist
 * in the cache then the Fetch method is used to retrieve the value
 * from another loader.
 *
 * @param key    or the item required
 * @param loader to fetch the items from
 * @return An instance of the value associated with the key
 * @throws IOExceptionError, error
 */
func (llc *LruLoadingCache) GetWithLoadingCache(key interface{}, loader IValueLoader) (interface{}, error) {
	result, err := llc.LruCacheBase.Get(key);
	if err != nil {
		return nil, err
	}
	if result == nil && loader != nil {
		result, err = loader.Load(key)
		if err != nil {
			return nil, IOExceptionError
		}
		_, err := llc.Add(key, result)
		if err != nil {
			return nil,err
		}
		return result,nil
	}
	return result,nil
}